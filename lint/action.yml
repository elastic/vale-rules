name: 'Elastic Vale Linter - Lint'
description: 'Run Vale with Elastic style guide on documentation files (Step 1: Linting)'
author: 'Elastic'

branding:
  icon: 'check-circle'
  color: 'blue'

inputs:
  files:
    description: 'Files or directories to lint (space-separated). If not provided, lints changed files in PR.'
    required: false
    default: ''
  include-paths:
    description: 'Paths to include for linting. Supports glob patterns. Can be space-separated or multi-line. Only files matching these paths will be linted.'
    required: false
    default: ''
  fail_on_error:
    description: 'Fail the action if Vale finds error-level issues'
    required: false
    default: 'false'
  vale_version:
    description: 'Vale version to install (default: latest via package manager)'
    required: false
    default: 'latest'
  debug:
    description: 'Enable debug output'
    required: false
    default: 'false'
  use_local_styles:
    description: 'Use local styles directory instead of downloading from releases (for testing local changes)'
    required: false
    default: 'false'
  styles_path:
    description: 'Path to local styles directory (only used when use_local_styles is true). Defaults to action repository root.'
    required: false
    default: ''
  disable_telemetry:
    description: 'Disable telemetry logging (for testing)'
    required: false
    default: 'false'
  upload_artifact:
    description: 'Upload Vale results as artifact (default: true)'
    required: false
    default: 'true'
  artifact_name:
    description: 'Name for the uploaded artifact (only used when upload_artifact is true)'
    required: false
    default: 'vale-results'

runs:
  using: 'composite'
  steps:
    - name: Validate dependencies
      shell: bash
      run: |
        # Check required tools
        if ! command -v jq &> /dev/null; then
          echo "::error::jq is not installed. Please install jq on your runner."
          exit 1
        fi

        if ! command -v python3 &> /dev/null; then
          echo "::error::python3 is not installed. Please install Python 3 on your runner."
          exit 1
        fi

        if ! command -v git &> /dev/null; then
          echo "::error::git is not installed. Please install git on your runner."
          exit 1
        fi

        echo "✓ All dependencies are available"

    - name: Detect OS
      id: detect-os
      shell: bash
      run: |
        if [[ "$OSTYPE" == "darwin"* ]]; then
          echo "os=macos" >> $GITHUB_OUTPUT
        elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
          echo "os=linux" >> $GITHUB_OUTPUT
        else
          echo "os=unknown" >> $GITHUB_OUTPUT
        fi

    - name: Install Vale (macOS)
      if: steps.detect-os.outputs.os == 'macos'
      shell: bash
      run: |
        if ! command -v vale &> /dev/null; then
          echo "Installing Vale via Homebrew..."
          brew install vale
        else
          echo "Vale is already installed: $(vale --version)"
        fi

    - name: Install Vale (Linux)
      if: steps.detect-os.outputs.os == 'linux'
      shell: bash
      run: |
        if ! command -v vale &> /dev/null; then
          echo "Installing Vale via snap..."
          sudo snap install vale
        else
          echo "Vale is already installed: $(vale --version)"
        fi

    - name: Configure Vale with released styles
      if: inputs.use_local_styles != 'true'
      shell: bash
      run: |
        # Create a minimal .vale.ini for this run
        # Vale will download the package and merge its .vale.ini automatically
        cat > .vale.ini.temp << 'EOF'
        StylesPath = .vale-styles

        Packages = https://github.com/elastic/vale-rules/releases/latest/download/elastic-vale.zip
        EOF

        # Sync the Elastic style package (downloads styles and merges packaged config)
        echo "Downloading Elastic style guide..."
        if ! vale --config=.vale.ini.temp sync 2>&1; then
          echo "::error::Vale sync failed. Check if the package URL is accessible: https://github.com/elastic/vale-rules/releases/latest/download/elastic-vale.zip"
          exit 1
        fi

        echo "Vale configured with Elastic style guide (released)"

    - name: Configure Vale with local styles
      if: inputs.use_local_styles == 'true'
      shell: bash
      env:
        STYLES_PATH: ${{ inputs.styles_path }}
      run: |
        # Use local .vale.ini and styles directory for testing
        # This allows testing Vale rule changes before they're released

        # Determine the styles source path
        if [ -n "${STYLES_PATH}" ]; then
          SOURCE_PATH="${STYLES_PATH}"
        else
          # Default to the action's repository root (where this action is checked out)
          SOURCE_PATH="${{ github.action_path }}/.."
        fi

        echo "Using local styles from: ${SOURCE_PATH}"

        # Verify local .vale.ini exists
        if [ ! -f "${SOURCE_PATH}/.vale.ini" ]; then
          echo "::error::Local .vale.ini not found at ${SOURCE_PATH}/.vale.ini"
          exit 1
        fi

        # Verify local styles directory exists
        if [ ! -d "${SOURCE_PATH}/styles" ]; then
          echo "::error::Local styles directory not found at ${SOURCE_PATH}/styles"
          exit 1
        fi

        # Copy local config and styles to workspace
        # Modify StylesPath to point to .vale-styles (consistent with released styles path)
        sed 's|^StylesPath = styles|StylesPath = .vale-styles|' "${SOURCE_PATH}/.vale.ini" > .vale.ini.temp
        mkdir -p .vale-styles
        cp -r "${SOURCE_PATH}/styles/"* .vale-styles/

        echo "Vale configured with local styles"
        echo "Styles copied from: ${SOURCE_PATH}/styles"
        ls -la .vale-styles/

    - name: Get changed files
      id: changed-files
      if: inputs.files == ''
      shell: bash
      run: |
        # Only get changed files if running in a PR context
        if [ -n "${{ github.event.pull_request.base.sha }}" ]; then
          echo "Detecting changed files in PR..."
          git diff --name-only --diff-filter=d ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }} \
            | grep -E '\.(md|adoc)$' > changed_files.txt || echo "No markdown/adoc files changed"

          if [ -s changed_files.txt ]; then
            echo "Found changed files:"
            cat changed_files.txt
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            echo "No markdown or adoc files changed in this PR"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "Not running in PR context, no files to check"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi

    - name: Determine files to lint
      id: files-to-lint
      shell: bash
      env:
        INPUT_FILES: ${{ inputs.files }}
      run: |
        if [ -n "${INPUT_FILES}" ]; then
          echo "Using provided files: ${INPUT_FILES}"
          echo "${INPUT_FILES}" | tr ' ' '\n' > files_to_lint.txt
          echo "has_files=true" >> $GITHUB_OUTPUT
        elif [ "${{ steps.changed-files.outputs.has_changes }}" == "true" ]; then
          echo "Using changed files from PR"
          cp changed_files.txt files_to_lint.txt
          echo "has_files=true" >> $GITHUB_OUTPUT
        else
          echo "No files to lint"
          echo "has_files=false" >> $GITHUB_OUTPUT
        fi

    - name: Filter files by include-paths
      id: filter-paths
      if: steps.files-to-lint.outputs.has_files == 'true' && inputs.include-paths != ''
      shell: bash
      env:
        INCLUDE_PATHS: ${{ inputs.include-paths }}
        DEBUG: ${{ inputs.debug }}
      run: |
        python3 ${{ github.action_path }}/path_filter.py

    - name: Update has_files output after filtering
      id: final-files-check
      if: steps.files-to-lint.outputs.has_files == 'true'
      shell: bash
      run: |
        # Check if files_to_lint.txt exists and has content after potential filtering
        if [ -f files_to_lint.txt ] && [ -s files_to_lint.txt ]; then
          echo "has_files=true" >> $GITHUB_OUTPUT
        else
          echo "has_files=false" >> $GITHUB_OUTPUT
        fi

    - name: Setup temp directory
      id: setup-temp
      if: steps.final-files-check.outputs.has_files == 'true'
      shell: bash
      env:
        DEBUG: ${{ inputs.debug }}
      run: |
        # Create temp directory for Vale operation
        TEMP_DIR=$(mktemp -d -t vale-lint-XXXXXX)
        echo "temp_dir=$TEMP_DIR" >> $GITHUB_OUTPUT
        echo "Created temp directory: $TEMP_DIR"

        if [ "${DEBUG}" == "true" ]; then
          echo "::debug::Temp directory created at $TEMP_DIR"
        fi

    - name: Get modified line ranges
      id: modified-lines
      if: steps.final-files-check.outputs.has_files == 'true' && github.event.pull_request.base.sha != ''
      shell: bash
      env:
        TEMP_DIR: ${{ steps.setup-temp.outputs.temp_dir }}
      run: |
        echo "Getting modified line ranges for each file..."

        # Create a file to store line ranges: filename|start_line|line_count
        > "$TEMP_DIR/line_ranges.txt"

        while IFS= read -r file; do
          if [ -f "$file" ]; then
            # Get line ranges from git diff
            # Note: Use { grep ... || true; } to handle files with no @@ hunks (e.g., binary files)
            # Without this, grep returns exit code 1 when no matches, failing the pipeline with pipefail
            git diff -U0 --diff-filter=d ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }} "$file" 2>/dev/null \
              | { grep '^@@' || true; } | while read -r line; do
                # Extract start line and count from @@ -x,y +a,b @@
                range=$(echo "$line" | sed -n 's/^@@ -[0-9,]* +\([0-9]*\),*\([0-9]*\).*/\1 \2/p')
                start=$(echo "$range" | awk '{print $1}')
                count=$(echo "$range" | awk '{print $2}')

                # If count is empty, it means only 1 line was changed
                if [ -z "$count" ]; then
                  count=1
                fi

                echo "$file|$start|$count" >> "$TEMP_DIR/line_ranges.txt"
              done
          fi
        done < files_to_lint.txt

        if [ -s "$TEMP_DIR/line_ranges.txt" ]; then
          echo "Modified line ranges:"
          cat "$TEMP_DIR/line_ranges.txt"

          # Copy to workspace for Python script
          cp "$TEMP_DIR/line_ranges.txt" line_ranges.txt
        fi

    - name: Run Vale and generate report
      id: vale-report
      if: steps.final-files-check.outputs.has_files == 'true'
      shell: bash
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        DEBUG: ${{ inputs.debug }}
        DISABLE_TELEMETRY: ${{ inputs.disable_telemetry }}
      run: |
        if [ "${DEBUG}" == "true" ]; then
          echo "::debug::Running Vale with debug mode enabled"
          set -x
        fi

        echo "Running Vale on files..."
        
        # Show files to lint
        echo "Files to lint:"
        cat files_to_lint.txt
        
        # Verify Vale config exists
        if [ ! -f .vale.ini.temp ]; then
          echo "::error::Vale config file .vale.ini.temp not found"
          exit 1
        fi
        
        # Verify styles were downloaded
        if [ ! -d .vale-styles ]; then
          echo "::error::Vale styles directory .vale-styles not found. Vale sync may have failed."
          exit 1
        fi

        # Run Vale with JSON output on all files
        # Capture stderr separately to avoid corrupting JSON output
        VALE_STDERR=$(mktemp)
        VALE_EXIT=0
        vale --config=.vale.ini.temp --output=JSON $(cat files_to_lint.txt | tr '\n' ' ') > vale_output.json 2>"$VALE_STDERR" || VALE_EXIT=$?
        
        if [ $VALE_EXIT -ne 0 ]; then
          echo "Vale exited with code $VALE_EXIT"
          if [ -s "$VALE_STDERR" ]; then
            echo "Vale stderr output:"
            cat "$VALE_STDERR"
          fi
        fi
        rm -f "$VALE_STDERR"

        # Check if vale_output.json exists and is valid JSON
        if [ ! -f vale_output.json ]; then
          echo "::warning::vale_output.json was not created"
        elif ! jq empty vale_output.json 2>/dev/null; then
          echo "::warning::vale_output.json is not valid JSON. Contents:"
          head -20 vale_output.json
        fi
        
        if [ ! -f vale_output.json ] || ! jq empty vale_output.json 2>/dev/null; then
          echo "No issues found or Vale produced no output"
          echo "has_issues=false" >> $GITHUB_OUTPUT
          echo "error_count=0" >> $GITHUB_OUTPUT

          # Create clean report
          {
            echo "## ✅ Vale Linting Results"
            echo ""
            echo "**No issues found on modified lines!**"
            echo ""
            echo "---"
            echo ""
            echo "The Vale linter checks documentation changes against the [Elastic Docs style guide](https://www.elastic.co/docs/contribute-docs/style-guide)."
            echo ""
            echo "To use Vale locally or report issues, refer to [Elastic style guide for Vale](https://www.elastic.co/docs/contribute-docs/vale-linter)."
          } > vale_report.md
          
          # Also create issue_counts.txt for artifact upload
          echo "errors=0" > issue_counts.txt
          echo "warnings=0" >> issue_counts.txt
          echo "suggestions=0" >> issue_counts.txt
          exit 0
        fi

        # Run the Python reporter script
        echo "Running vale_reporter.py..."
        python3 ${{ github.action_path }}/vale_reporter.py

        # Set outputs from the generated counts file
        if [ -f issue_counts.txt ]; then
          source issue_counts.txt

          if [ $errors -gt 0 ] || [ $warnings -gt 0 ] || [ $suggestions -gt 0 ]; then
            echo "has_issues=true" >> $GITHUB_OUTPUT
          else
            echo "has_issues=false" >> $GITHUB_OUTPUT
          fi

          echo "error_count=$errors" >> $GITHUB_OUTPUT
          echo "warning_count=$warnings" >> $GITHUB_OUTPUT
          echo "suggestion_count=$suggestions" >> $GITHUB_OUTPUT

          if [ "${DEBUG}" == "true" ]; then
            echo "::debug::Errors: $errors, Warnings: $warnings, Suggestions: $suggestions"
          fi
        else
          echo "::warning::Failed to read issue counts"
          echo "has_issues=false" >> $GITHUB_OUTPUT
          echo "error_count=0" >> $GITHUB_OUTPUT
        fi

    - name: Write Job Summary
      if: always() && steps.final-files-check.outputs.has_files == 'true'
      shell: bash
      run: |
        if [ -f vale_report.md ]; then
          cat vale_report.md >> $GITHUB_STEP_SUMMARY
        fi

    - name: Upload Vale results
      if: always() && steps.final-files-check.outputs.has_files == 'true' && inputs.upload_artifact == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.artifact_name }}
        path: |
          vale_report.md
          issue_counts.txt
        retention-days: 1

    - name: Fail on errors
      if: inputs.fail_on_error == 'true' && steps.vale-report.outputs.error_count != '0'
      shell: bash
      run: |
        echo "❌ Vale found ${{ steps.vale-report.outputs.error_count }} error-level issue(s)"
        exit 1

    - name: Cleanup
      if: always()
      shell: bash
      env:
        TEMP_DIR: ${{ steps.setup-temp.outputs.temp_dir }}
        DEBUG: ${{ inputs.debug }}
      run: |
        if [ "${DEBUG}" == "true" ]; then
          echo "::debug::Cleaning up temporary files"
        fi

        # Clean up workspace files (keep artifacts for upload)
        rm -f .vale.ini.temp
        rm -f changed_files.txt
        rm -f files_to_lint.txt
        rm -f vale_output.json
        rm -f line_ranges.txt
        rm -rf .vale-styles

        # Clean up temp directory if it exists
        if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
          rm -rf "$TEMP_DIR"
          if [ "${DEBUG}" == "true" ]; then
            echo "::debug::Removed temp directory: $TEMP_DIR"
          fi
        fi

        echo "✓ Cleanup complete"
